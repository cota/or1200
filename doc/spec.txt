OpenRISC 1200 IP Core Specification (Preliminary Draft)
=======================================================
:doctype: book

////
Revision history
Note: When adding new entries, strictly follow the format of the existing ones.

Rev.	| Date		| Author	| Description
__vstart__
v0.1	| 28/3/01	| Damjan Lampret	| First Draft

v0.2	| 16/4/01	| Damjan Lampret	| First time published

v0.3	| 29/4/01	| Damjan Lampret	| All chapters almost
finished. Some bugs hidden waiting for an update. Awaiting feedback.

v0.4	| 16/5/01	| Damjan Lampret	| Synchronization with
OR1K Arch Manual

v0.5	| 24/5/01	| Damjan Lampret	| Fixed bugs

v0.6	| 28/5/01	| Damjan Lampret	| Changed some SPR addresses.

v0.7	| 06/9/01	| Damjan Lampret	| Simplified debug unit.

v0.8	| 30/08/10	| Julius Baxter		| Adding information about FPU
implementation, data cache write-back capability. PIC behavior update.
Instruction list update. Update of bits in config registers, bringing into
line with latest OR1200 â€“ not entirely complete.

v0.9	| 12/9/10	| Julius Baxter		| Clarified supported parts of
OR1K instruction set. Updated core clock input information.
Fixed up reference to instruction execute stage cycle table.
Added divide cycles to execute stage cycle table.

0.10	| 1/11/10	| Julius Baxter		| Added FF1/FL1 instructions to
supported instructions table.

v0.11	| 19/1/11	| Julius Baxter	| Cache information update.
Wishbone behavior clarification. Serial integer multiply/divide update.
Reset address clarification
__vend__
////

Introduction
------------

Purpose of this document is to define specifications of the OpenRISC 1200
implementation. This specification defines all implementation specific
variables that are not part of the general architecture specification. This
includes type and size of data and instruction caches, type and size of data
and instruction MMUs, details of all execution pipelines, implementation
of exception unit, interrupt controller and other supplemental units.
This document does not cover general architecture topics like instruction set,
memory addressing modes and other architectural definitions. See OpenRISC
1000 System Architecture Manual for more information about architecture.

OpenRISC Family
~~~~~~~~~~~~~~~
OpenRISC 1000 is architecture for a family of free, open source RISC processor
cores. As architecture, OpenRISC 1000 allows for a spectrum of chip and
system implementations at a variety of price/performance points for a range of
applications. It is a 32/64-bit load and store RISC architecture designed with
emphasis on performance, simplicity, low power requirements, scalability and
versatility. OpenRISC 1000 architecture targets medium and high performance
networking, embedded, automotive and portable computer environments.

image::img/or_family.gif[scaledwidth="50%",align="center"]

All OpenRISC implementations, whose first digit in identification number
is  1 , belong to OpenRISC 1000 family. Second digit defines which features
of OpenRISC 1000 architecture are implemented and in which way they are
implemented. Last two digits define how an implementation is configured
before it is used in a real application.

However, at present the OR1200 is the only major RTL implementation of the
OR1K architecture spec, and the OR1200 name has stuck, despite the high level
of reconfigurability possible that would, strictly speaking, mean the core
is either a OR1000, OR1300, etc. So, despite the various features that may
or may not be implemented, the core is still only referred to as the OR1200.

OpenRISC 1200
~~~~~~~~~~~~~
The OR1200 is a 32-bit scalar RISC with Harvard microarchitecture, 5 stage
integer pipeline, virtual memory support (MMU) and basic DSP capabilities.
Default caches are 1-way direct-mapped 8KB data cache and 1-way direct-mapped
8KB instruction cache, each with 16-byte line size. Both caches are
physically tagged.  By default MMUs are implemented and they are constructed of
64-entry hash based 1-way direct-mpped data TLB and 64-entry hash based 1-way
direct-mapped instruction TLB.

Supplemental facilities include debug unit for real-time debugging, high
resolution tick timer, programmable interrupt controller and power management
support.  When implemented in a typical 0.18u 6LM process it should provide
over 300 dhrystone 2.1 MIPS at 300MHz and 300 DSP MAC 32x32 operations, at
least 20% more than any other competitor in this class. OR1200 in default
configuration has about 1M transistors.

OR1200 is intended for embedded, portable and networking applications. It can
successfully compete with latest scalar 32-bit RISC processors in his class
and can efficiently run any modern operating system.  Competitors include
ARM10, ARC and Tensilica RISC processors.

Features
^^^^^^^^
The following lists the main features of OR1200 IP core:

- All major characteristics of the core can be set by the user
- High performance of 300 Dhrystone 2.1 MIPS at 300 MHz using 0.18u process
- High performance cache and MMU subsystems
- WISHBONE SoC Interconnection Rev. B3 compliant interface

Architecture
------------
<<core_arch_img>> below shows general architecture of OR1200 IP core. It
consists of several building blocks:

- CPU/FPU/DSP central block
- Direct-mapped data cache
- Direct-mapped instruction cache
- Data MMU based on hash based DTLB
- Instruction MMU based on hash based ITLB
- Power management unit and power management interface
- Tick timer
- Debug unit and development interface
- Interrupt controller and interrupt interface
- Instruction and Data WISHBONE host interfaces

[[core_arch_img]]
.Core's Architecture
image::img/core_arch.gif[scaledwidth="50%",align="center"]

CPU/FPU/DSP
~~~~~~~~~~~
CPU/FPU/DSP is a central part of the OR1200 RISC processor. Figure 2 shows
basic block diagram of the CPU/DSP. Not pictured are the FPU components.
OR1200 CPU/FPU/DSP ony implements sections of the ORBIS32 and ORFPX32
instruction set. No ORBIS64, ORFBX64 or ORVDX64 instructions are  implemented
in OR1200.

[[cpu_fpu_dsp_img]]
.CPU/FPU/DSP Block Diagram
image::img/cpu_fpu_dsp.gif[scaledwidth="50%",align="center"]

Instruction unit
^^^^^^^^^^^^^^^^
The instruction unit implements the basic instruction pipeline, fetches
instructions from the memory subsystem, dispatches them to available execution
units, and maintains a state history to ensure a precise exception model
and that operations finish in order. It also executes conditional branch
and unconditional jump instructions.

The sequencer can dispatch a sequential instruction on each clock if the
appropriate execution unit is available. The execution unit must discern
whether source data is available and to ensure that no other instruction is
targeting the same destination register.

Instruction unit handles only ORBIS32 and, optionally, a subset of the ORFPX32
instruction class. Some ORFPX32 and all ORFPX3264 and ORVDX64 instruction
classes are not supported by the OR1200 at present.

General-Purpose Registers
^^^^^^^^^^^^^^^^^^^^^^^^^
OpenRISC 1200 implements 32 general-purpose 32-bit registers. OpenRISC 1000
architecture also support shadow copies of register file to implement fast
switching between working contexts, however this feature is not implemented
in current OR1200 implementation.

OR1200 implements general-purpose register file as two synchronous dual-port
memories with capacity of 32 words by 32 bits per word.

Load/Store Unit
^^^^^^^^^^^^^^^

The load/store unit (LSU) transfers all data between the GPRs and the CPU's
internal bus. It is implemented as an independent execution unit so that stalls
in memory subsystem only affect master pipeline if there is a data dependency.

The following are LSU's main features:

- all load/store instruction implemented in hardware (atomic instructions
  included)
- address entry buffer
- pipelined operation
- aligned accesses for fast memory access

When load and store instructions are issued, the LSU determines if all
operands are available. These operands include the following:

- address register operand
- source data register operand (for store instructions)
- destination data register operand (for load instructions)

Integer Execution Pipeline
^^^^^^^^^^^^^^^^^^^^^^^^^^
The core implements the following types of 32-bit integer instructions:

- Arithmetic instructions
- Compare instructions
- Logical instructions
- Rotate and shift instructions

Most integer instructions can execute in one cycle. For details about timing
see <<exec_time_int_table>>.

MAC Unit
^^^^^^^^
The MAC unit executes DSP MAC operations. MAC operations are 32x32 with
48-bit accumulator. MAC unit is fully pipelined and can accept new MAC
operation in each new clock cycle.

Floating Point Unit
^^^^^^^^^^^^^^^^^^^
The FPU implementation is based on two other FPUs available from OpenCores.org
For the comparison and conversion functions, parts were taken from the FPU
project by Rudolf Usselmann, and for the arithmetic operations, the fpu100
project by Jidan Al-Eryani was converted to Verilog HDL.

All ORFPX32 instructions except for lf.madd.s and lf.rem.s are supported
when the FPU is enabled in the OR1200 configuration.

System Unit
^^^^^^^^^^^
The system unit connects all other signals of the CPU/FPU/DSP that are not
connected through instruction and data interfaces. It also implements all
system special-purpose registers (e.g. supervisor register).

Exceptions
^^^^^^^^^^
Core exceptions can be generated when an exception condition occurs. Exception
sources in OR1200 include the following:

- External interrupt request
- Certain memory access condition
- Internal errors, such as an attempt to execute unimplemented opcode
- System call
- Internal exception, such as breakpoint exceptions

Exception handling is transparent to user software and uses the same mechanism
to handle all types of exceptions. When an exception is taken, control is
transferred to an exception handler at an offset defined by for the type of
exception encountered. Exceptions are handled in supervisor mode.

Data Cache
~~~~~~~~~~
The default configuration of OR1200 data cache is 8-Kbyte, 1-way direct-mapped
data cache, which allows rapid core access to data. However data cache can
be configured according to <<data_confs_or1200_table>>.

[[data_confs_or1200_table]]
.Possible Data Cache Configurations of OR1200
[width="60%",options="header"]
|======================================================
|					| Direct mapped
| 16B/line, 256 lines, 1 way		| 4KB
| 16B/line, 512 lines, 1 way		| *8KB (default)*
| 16B/line, 1024 lines, 1 way		| 16KB
| 32B/line, 1024 lines, 1 way		| 32KB
|======================================================

It is possible to operate the data cache with write-through or write-back
strategies, however write-back is currently experimental.

Features:

- data cache is separate from instruction cache (Harvard architecture)
- data cache implements a least-recently used (LRU) replacement algorithm
  within each set
- the cache directory is physically addressed. The physical address tag is
  stored in the cache directory
- write-through or write-back operation
- entire cache can be disabled, lines invalidated, flushed or forced to be
  written back, by writing to cache special purpose registers

On a miss, and appropriate conditions, the cache line is filled or emptied
(written back) with 16-byte bursts. The burst fill is performed as a
critical-word-first operation; the critical word is simultaneously written
to the cache and forwarded to the requesting unit, thus minimizing stalls
due to cache fill latency. Data cache provides storage for cache tags and
performs cache line replacement function.

Data cache is tightly coupled to external interface to allow efficient
access to the system memory controller.

The data cache supplies data to the GPRs by means of a 32-bit interface
to the load/store unit. The LSU provides all logic required to calculate
effective addresses, handles data alignment to and from the data cache,
and provides sequencing for load and store operations. Write operations to
the data cache can be performed on a byte, half-word or word basis.

image::img/data_cache_diag.gif[scaledwidth="50%",align="center"]

Each line contains four contiguous words from memory that are loaded from
a cache line aligned boundary. As a result, cache lines are aligned with
page boundaries.

Instruction Cache
~~~~~~~~~~~~~~~~~
The default configuration of OR1200 instruction cache is 8-Kbyte, 1-way
direct mapped instruction cache, which allows rapid core access to
instructions. However instruction cache can be configured according to
<<inst_confs_or1200_table>>.

[[inst_confs_or1200_table]]
.Possible Instruction Cache Configurations of OR1200
[width="60%",options="header"]
|==============================================
|				| Direct mapped
| 16B/line, 32 lines, 1 way	| 512B
| 16B/line, 256 lines, 1 way	| 4KB
| 16B/line, 512 lines, 1 way	| *8KB (Default)*
| 16B/line, 1024 lines, 1 way	| 16KB
| 32B/line, 1024 lines, 1 way	| 32KB
|==============================================

Features:

- instruction cache is separate from data cache (Harvard architecture)
- instruction cache implements a least-recently used (LRU) replacement
  algorithm within each set
- the cache directory is physically addressed. The physical address tag is
  stored in the cache directory
- it can be disabled or invalidated by writing to cache special purpose
  registers

On a miss, the cache is filled in with 16-byte bursts. The burst fill
is performed as a critical-word-first operation; the critical word is
simultaneously written to the cache and forwarded to the requesting unit,
thus minimizing stalls due to cache fill latency. Instruction cache provides
storage for cache tags and performs cache line replacement function.

Instruction cache is tightly coupled to external interface to allow efficient
access to the system memory controller.

The instruction cache supplies instructions to the instruction sequencer by
means of a 32-bit interface to the instruction fetch subunit. The instruction
fetch subunit provides all logic required to calculate effective addresses.

image::img/inst_cache_diag.gif[scaledwidth="50%",align="center"]

Each line contains four contiguous words from memory that are loaded from
a line-size  aligned boundary. As a result, cache lines are aligned with
page boundaries.

Data MMU
~~~~~~~~
The OR1200 implements a virtual memory management scheme that provides memory
access protection and effective-to-physical address translation. Protection
granularity is as defined by OpenRISC 1000 architecture - 8-Kbyte and
16-Mbyte pages.

[[tlb_confs_or1200_table]]
.Possible Data TLB Configurations of OR1200
[width="60%",options="header"]
|======================================
|			| Direct mapped
| 16 entries per way	| 16 DTLB entries
| 32 entries per way	| 32 DTLB entries
| 64 entries per way	| *64 DTLB entries (default)*
| 128 entries per way	| 128 DTLB entries
|======================================

Features:

* data MMU is separate from instruction MMU
* page size 8-Kbyte
* comprehensive page protection scheme
* direct mapped hash based translation lookaside buffer (DTLB) with the
  default of 1 way and the following features:
** miss and fault exceptions
** software tablewalk
** high performance because of hashed based design
** variable number DTLB entries with default of 64 per each way

image::img/tlb_diag.gif[scaledwidth="50%",align="center"]

The MMU hardware supports two-level software tablewalk.

Instruction MMU
~~~~~~~~~~~~~~~


[[exec_time_int_table]]
.Execution Time of Integer Instructions
[width="60%",options="header"]
|================================================
| Instruction Group	| Clock Cycles to Execute
| Arithmetic except Multiply/Divide	| 1
| Multiply				| 3
| Divide				| 32
| Compare				| 1
| Logical				| 1
| Rotate and Shift			| 1
| Others				| 1
|================================================




[partintro]
.Optional part introduction title
--
Optional part introduction goes here.
--

The First Chapter
-----------------
Chapters can be grouped by preceeding them with a level 0 Book Part
title.

Book chapters are at level 1 and can contain sub-sections nested up to
three deep.
footnote:[An example footnote.]
indexterm:[Example index entry]

It's also worth noting that a book part can have it's own preface,
bibliography, glossary and index. Chapters can have their own
bibliography, glossary and index.

And now for something completely different: ((monkeys)), lions and
tigers (Bengal and Siberian) using the alternative syntax index
entries.
(((Big cats,Lions)))
(((Big cats,Tigers,Bengal Tiger)))
(((Big cats,Tigers,Siberian Tiger)))
Note that multi-entry terms generate separate index entries.

Followed by an example table:

.An example table
[width="60%",options="header"]
|==============================================
| Option          | Description
| -a 'USER GROUP' | Add 'USER' to 'GROUP'.
| -R 'GROUP'      | Disables access to 'GROUP'.
|==============================================

.An example example
===============================================
Lorum ipum...
===============================================

[[X1]]
Sub-section with Anchor
~~~~~~~~~~~~~~~~~~~~~~~
Sub-section at level 2.

Chapter Sub-section
^^^^^^^^^^^^^^^^^^^
Sub-section at level 3.

Chapter Sub-section
+++++++++++++++++++
Sub-section at level 4.

This is the maximum sub-section depth supported by the distributed
AsciiDoc configuration.
footnote:[A second example footnote.]


The Second Chapter
------------------
An example link to anchor at start of the <<X1,first sub-section>>.
indexterm:[Second example index entry]

An example link to a bibliography entry <<taoup>>.



The First Chapter of the Second Part
------------------------------------
Chapters grouped into book parts are at level 1 and can contain
sub-sections.

:numbered!:

[appendix]
Example Appendix
================
One or more optional appendixes go here at section level zero.

Appendix Sub-section
~~~~~~~~~~~~~~~~~~~
NOTE: Preface and appendix subsections start out of sequence at level
2 (level 1 is skipped).  This only applies to multi-part book
documents.



[bibliography]
Example Bibliography
====================
The bibliography list is a style of AsciiDoc bulleted list.

[bibliography]
- [[[taoup]]] Eric Steven Raymond. 'The Art of Unix
  Programming'. Addison-Wesley. ISBN 0-13-142901-9.
- [[[walsh-muellner]]] Norman Walsh & Leonard Muellner.
  'DocBook - The Definitive Guide'. O'Reilly & Associates. 1999.
  ISBN 1-56592-580-7.


[glossary]
Example Glossary
================
Glossaries are optional. Glossaries entries are an example of a style
of AsciiDoc labeled lists.

[glossary]
A glossary term::
  The corresponding (indented) definition.

A second glossary term::
  The corresponding (indented) definition.


[colophon]
Example Colophon
================
Text at the end of a book describing facts about its production.


[index]
Example Index
=============
////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents are
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
